---
phase: 03-soldier-profiles-and-service-records
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260211000004_phase3_profiles.sql
  - src/lib/types/database.ts
  - src/routes/(app)/+layout.server.ts
  - src/routes/(app)/+layout.svelte
autonomous: true

must_haves:
  truths:
    - "operations and operation_attendance tables exist in the database with RLS enabled"
    - "Authenticated members can read ALL soldiers' profiles (not just active ones) for profile page access"
    - "Members can read their own service records including leadership_only entries"
    - "The soldiers status constraint includes 'retired' as a valid value"
    - "The (app) layout provides mySoldierId for 'My Profile' navigation"
    - "The (app) layout renders a navigation bar with links to dashboard and my profile"
    - "database.ts types include operations and operation_attendance tables"
  artifacts:
    - path: "supabase/migrations/20260211000004_phase3_profiles.sql"
      provides: "Schema migration for Phase 3 tables, constraints, and RLS policies"
      contains: "create table public.operations"
    - path: "src/lib/types/database.ts"
      provides: "Updated TypeScript types reflecting new tables"
      contains: "operations"
    - path: "src/routes/(app)/+layout.server.ts"
      provides: "Auth-gated layout load with mySoldierId lookup"
      exports: ["load"]
    - path: "src/routes/(app)/+layout.svelte"
      provides: "App shell layout with navigation bar"
      min_lines: 15
  key_links:
    - from: "src/routes/(app)/+layout.server.ts"
      to: "soldiers table"
      via: "supabase query for mySoldierId"
      pattern: "from.*soldiers.*eq.*user_id"
    - from: "src/routes/(app)/+layout.svelte"
      to: "/soldiers/{id}"
      via: "My Profile nav link using mySoldierId"
      pattern: "soldiers.*mySoldierId"
---

<objective>
Create the database infrastructure and app shell navigation required for Phase 3 soldier profiles.

Purpose: All subsequent profile page work depends on (a) operations/operation_attendance tables existing, (b) correct RLS policies for profile viewing, (c) the "My Profile" navigation link in the (app) layout, and (d) updated TypeScript types reflecting the new schema.

Output: Migration applied to Supabase, database.ts regenerated, (app) layout with navigation bar and mySoldierId.
</objective>

<execution_context>
@/home/iancrowder/.claude/get-shit-done/workflows/execute-plan.md
@/home/iancrowder/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-soldier-profiles-and-service-records/03-RESEARCH.md
@supabase/migrations/20260211000000_initial_schema.sql
@supabase/migrations/20260211000001_rls_policies.sql
@supabase/migrations/20260211000003_phase2_public_site.sql
@src/routes/(app)/+layout.server.ts
@src/lib/types/database.ts
@src/lib/auth/roles.ts
@src/hooks.server.ts
@src/app.css
</context>

<important_note>
NPM_CONFIG_PREFIX=/nonexistent is set in the shell environment. ALL npm/npx commands MUST use `env -u NPM_CONFIG_PREFIX` prefix. Example: `env -u NPM_CONFIG_PREFIX npx supabase gen types ...`

For database operations, use Supabase MCP tools (apply_migration, execute_sql) instead of the Supabase CLI. The MCP tools are linked and work for migrations.
</important_note>

<tasks>

<task type="auto">
  <name>Task 1: Apply Phase 3 database migration</name>
  <files>supabase/migrations/20260211000004_phase3_profiles.sql</files>
  <action>
Create a migration file at `supabase/migrations/20260211000004_phase3_profiles.sql` with the following contents, then apply it using the Supabase MCP `apply_migration` tool:

1. **Add 'retired' to soldiers status check constraint:**
   ```sql
   ALTER TABLE public.soldiers DROP CONSTRAINT IF EXISTS soldiers_status_check;
   ALTER TABLE public.soldiers ADD CONSTRAINT soldiers_status_check
     CHECK (status IN ('active', 'inactive', 'loa', 'awol', 'discharged', 'retired'));
   ```

2. **Create operations table** (internal completed ops for attendance tracking, separate from public `events` table):
   ```sql
   CREATE TABLE public.operations (
     id             uuid PRIMARY KEY DEFAULT gen_random_uuid(),
     title          text NOT NULL,
     operation_date timestamptz NOT NULL,
     operation_type text NOT NULL CHECK (operation_type IN ('operation', 'training', 'ftx')),
     status         text NOT NULL DEFAULT 'completed'
                      CHECK (status IN ('scheduled', 'completed', 'cancelled')),
     description    text,
     created_by     uuid REFERENCES auth.users(id) ON DELETE SET NULL,
     created_at     timestamptz NOT NULL DEFAULT now()
   );
   ALTER TABLE public.operations ENABLE ROW LEVEL SECURITY;
   ```

3. **Create operation_attendance table** (soldier x operation join):
   ```sql
   CREATE TABLE public.operation_attendance (
     id           uuid PRIMARY KEY DEFAULT gen_random_uuid(),
     soldier_id   uuid NOT NULL REFERENCES public.soldiers(id) ON DELETE CASCADE,
     operation_id uuid NOT NULL REFERENCES public.operations(id) ON DELETE CASCADE,
     status       text NOT NULL CHECK (status IN ('present', 'excused', 'absent')),
     role_held    text,
     notes        text,
     recorded_by  uuid REFERENCES auth.users(id) ON DELETE SET NULL,
     created_at   timestamptz NOT NULL DEFAULT now(),
     UNIQUE (soldier_id, operation_id)
   );
   ALTER TABLE public.operation_attendance ENABLE ROW LEVEL SECURITY;
   ```

4. **RLS policies for operations:**
   ```sql
   -- Authenticated can read completed operations
   CREATE POLICY "Authenticated can read completed operations"
     ON public.operations FOR SELECT TO authenticated
     USING (status = 'completed');

   -- NCO+ can manage all operations
   CREATE POLICY "NCO and above can manage operations"
     ON public.operations FOR ALL TO authenticated
     USING (
       (SELECT (auth.jwt() ->> 'user_role')::public.app_role)
         IN ('nco', 'command', 'admin')
     );
   ```

5. **RLS policies for operation_attendance:**
   ```sql
   -- Members can read own attendance
   CREATE POLICY "Members can read own attendance"
     ON public.operation_attendance FOR SELECT TO authenticated
     USING (
       soldier_id IN (
         SELECT id FROM public.soldiers WHERE user_id = (SELECT auth.uid())
       )
     );

   -- NCO+ can read all attendance
   CREATE POLICY "NCO and above can read all attendance"
     ON public.operation_attendance FOR SELECT TO authenticated
     USING (
       (SELECT (auth.jwt() ->> 'user_role')::public.app_role)
         IN ('nco', 'command', 'admin')
     );

   -- NCO+ can manage attendance (insert/update/delete)
   CREATE POLICY "NCO and above can manage attendance"
     ON public.operation_attendance FOR ALL TO authenticated
     USING (
       (SELECT (auth.jwt() ->> 'user_role')::public.app_role)
         IN ('nco', 'command', 'admin')
     );
   ```

6. **New RLS policy on service_records** — members can read their OWN service records including leadership_only:
   ```sql
   CREATE POLICY "Members can read own service records"
     ON public.service_records FOR SELECT TO authenticated
     USING (
       soldier_id IN (
         SELECT id FROM public.soldiers WHERE user_id = (SELECT auth.uid())
       )
     );
   ```

7. **New RLS policy on soldiers** — authenticated can read ALL soldiers (not just active) for profile pages. The existing policy "Authenticated can read active soldiers" restricts to `status = 'active'`. Add a blanket authenticated SELECT so profile pages for LOA/AWOL/Discharged/Retired soldiers are accessible:
   ```sql
   CREATE POLICY "Authenticated can read all soldiers"
     ON public.soldiers FOR SELECT TO authenticated
     USING (true);
   ```
   Note: This is additive (PostgreSQL OR logic for permissive policies). The existing active-only policy remains but is now subsumed. The anon policy still restricts to active-only for the public site.

After writing the file, apply it with the Supabase MCP `apply_migration` tool. Then verify with `execute_sql`:
```sql
SELECT tablename FROM pg_tables WHERE schemaname = 'public' ORDER BY tablename;
```
Confirm `operations` and `operation_attendance` appear in the result.

Also verify the soldiers constraint:
```sql
SELECT conname, pg_get_constraintdef(oid) FROM pg_constraint WHERE conrelid = 'public.soldiers'::regclass AND conname = 'soldiers_status_check';
```
Confirm 'retired' appears in the constraint definition.
  </action>
  <verify>
Run via Supabase MCP execute_sql:
```sql
SELECT tablename FROM pg_tables WHERE schemaname = 'public' ORDER BY tablename;
```
Expected: operations and operation_attendance appear alongside soldiers, ranks, units, service_records, etc.

Also verify RLS is enabled:
```sql
SELECT tablename, rowsecurity FROM pg_tables WHERE schemaname = 'public' AND tablename IN ('operations', 'operation_attendance');
```
Expected: both show rowsecurity = true.
  </verify>
  <done>operations and operation_attendance tables exist with RLS enabled. soldiers status constraint includes 'retired'. New RLS policies allow: (a) authenticated read all soldiers, (b) members read own service records, (c) members read own attendance, (d) NCO+ manage operations and attendance.</done>
</task>

<task type="auto">
  <name>Task 2: Regenerate database.ts types</name>
  <files>src/lib/types/database.ts</files>
  <action>
Regenerate the Supabase TypeScript types to include the new `operations` and `operation_attendance` tables. Run:

```bash
env -u NPM_CONFIG_PREFIX npx supabase gen types typescript --project-id lelwuinxszfwnlquwsho > src/lib/types/database.ts
```

If this command fails due to auth issues, use the Supabase MCP `execute_sql` tool to query the schema and manually update `src/lib/types/database.ts` to add the `operations` and `operation_attendance` table types.

After regeneration, verify the file contains type definitions for:
- `operations` table with columns: id, title, operation_date, operation_type, status, description, created_by, created_at
- `operation_attendance` table with columns: id, soldier_id, operation_id, status, role_held, notes, recorded_by, created_at
  </action>
  <verify>
Check that `src/lib/types/database.ts` contains the string "operations" and "operation_attendance" as table names in the Database interface.
  </verify>
  <done>database.ts includes TypeScript types for operations and operation_attendance tables, matching the migration schema exactly.</done>
</task>

<task type="auto">
  <name>Task 3: Update (app) layout with navigation and mySoldierId</name>
  <files>src/routes/(app)/+layout.server.ts, src/routes/(app)/+layout.svelte</files>
  <action>
**Update `src/routes/(app)/+layout.server.ts`** to add a `mySoldierId` lookup. The layout already guards auth and returns `claims` and `userRole`. Extend it to also query the `soldiers` table for the current user's soldier ID:

```typescript
import { redirect } from '@sveltejs/kit'
import type { LayoutServerLoad } from './$types'

export const load: LayoutServerLoad = async ({ locals: { supabase, getClaims } }) => {
  const claims = await getClaims()

  if (!claims) {
    redirect(303, '/auth/login')
  }

  const userRole = (claims['user_role'] as string) ?? null

  // Look up the current user's soldier record for "My Profile" nav link
  const { data: mySoldier } = await supabase
    .from('soldiers')
    .select('id')
    .eq('user_id', claims.sub as string)
    .maybeSingle()

  return {
    claims,
    userRole,
    mySoldierId: mySoldier?.id ?? null,
  }
}
```

Use `.maybeSingle()` (not `.single()`) because a user might not have a soldier record yet (e.g., admin account, newly registered user). Returning `null` for `mySoldierId` is fine — the nav link is conditionally shown.

**Create `src/routes/(app)/+layout.svelte`** — this file does NOT currently exist. Create the app shell layout with a dark tactical navigation bar:

```svelte
<script lang="ts">
  import type { LayoutData } from './$types'
  import { roleLabel } from '$lib/auth/roles'

  let { data, children }: { data: LayoutData; children: import('svelte').Snippet } = $props()
</script>

<div class="min-h-screen bg-night text-steel">
  <!-- Navigation Bar -->
  <nav class="bg-night-surface border-b border-night-border px-4 py-3">
    <div class="max-w-6xl mx-auto flex items-center justify-between">
      <div class="flex items-center gap-6">
        <a href="/dashboard" class="text-ranger-tan font-tactical font-bold text-lg tracking-wider hover:text-ranger-tan-muted transition-colors">
          ASQN 1st SFOD
        </a>
        <div class="flex items-center gap-4 text-sm">
          <a href="/dashboard" class="text-steel hover:text-ranger-tan transition-colors">Dashboard</a>
          {#if data.mySoldierId}
            <a href="/soldiers/{data.mySoldierId}" class="text-steel hover:text-ranger-tan transition-colors">My Profile</a>
          {/if}
        </div>
      </div>
      <div class="flex items-center gap-3 text-sm">
        <span class="text-steel/70">{roleLabel(data.userRole)}</span>
        <form method="POST" action="/auth/logout">
          <button type="submit" class="text-steel hover:text-alert transition-colors">Logout</button>
        </form>
      </div>
    </div>
  </nav>

  <!-- Page Content -->
  <main>
    {@render children()}
  </main>
</div>
```

Key decisions:
- Uses Svelte 5 `$props()` with `children: Snippet` pattern (not Svelte 4 `<slot>`)
- Uses `{@render children()}` to render child pages
- "My Profile" link is conditionally shown only if `data.mySoldierId` is not null
- Uses existing Tailwind custom colors (night, night-surface, night-border, ranger-tan, steel, etc.)
- Logout form POSTs to `/auth/logout` — this route may not exist yet (that's fine, it will be added when needed)
- Does NOT reference the `(site)` layout — (app) and (site) are separate route groups with separate layouts

After creating the layout, update the existing `src/routes/(app)/dashboard/+page.svelte` to remove the duplicate `min-h-screen bg-black text-white` wrapper since the layout now provides it. Simplify to:

```svelte
<script lang="ts">
  import type { PageData } from './$types'

  let { data }: { data: PageData } = $props()
</script>

<div class="max-w-4xl mx-auto px-4 py-8">
  <h1 class="text-2xl font-bold text-ranger-tan mb-4 font-tactical">Dashboard</h1>
  <p class="text-steel">Welcome. You are authenticated.</p>
</div>
```
  </action>
  <verify>
Run `env -u NPM_CONFIG_PREFIX npm run build` to verify the project compiles without errors. The build should succeed with no TypeScript errors in the layout files.
  </verify>
  <done>(app) layout.server.ts returns mySoldierId alongside claims and userRole. (app) layout.svelte renders a navigation bar with Dashboard link and conditional "My Profile" link. Dashboard page updated to use layout wrapper instead of inline styles.</done>
</task>

</tasks>

<verification>
1. Run `env -u NPM_CONFIG_PREFIX npm run build` — project compiles without errors
2. Verify via Supabase MCP execute_sql that operations and operation_attendance tables exist with RLS enabled
3. Verify soldiers status constraint includes 'retired'
4. Verify database.ts contains operations and operation_attendance types
5. Verify (app)/+layout.svelte exists and references mySoldierId
</verification>

<success_criteria>
- Migration applied: operations, operation_attendance tables exist with correct columns, constraints, and RLS policies
- soldiers.status check constraint includes 'retired'
- service_records has "Members can read own service records" policy
- soldiers has "Authenticated can read all soldiers" policy (profile access for non-active statuses)
- database.ts types regenerated to include new tables
- (app) layout.server.ts returns mySoldierId from soldiers table lookup
- (app) layout.svelte renders navigation bar with conditional "My Profile" link
- Project builds without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-soldier-profiles-and-service-records/03-01-SUMMARY.md`
</output>
