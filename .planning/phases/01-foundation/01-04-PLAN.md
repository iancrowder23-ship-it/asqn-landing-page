---
phase: 01-foundation
plan: "04"
type: execute
wave: 3
depends_on:
  - "01-02"
  - "01-03"
files_modified:
  - supabase/migrations/20260211000002_custom_access_token_hook.sql
  - src/lib/auth/roles.ts
autonomous: false

user_setup:
  - service: supabase
    why: "Custom Access Token Hook must be registered in Supabase Dashboard — cannot be done via SQL migration alone"
    env_vars: []
    dashboard_config:
      - task: "Register Custom Access Token Hook"
        location: "Supabase Dashboard -> Authentication -> Hooks -> Custom Access Token Hook -> Add hook -> select function: public.custom_access_token_hook"
      - task: "Assign a Member role to your own Discord account for testing"
        location: "Run SQL in Supabase Dashboard -> SQL Editor: INSERT INTO public.user_roles (user_id, role) VALUES ('YOUR_AUTH_USER_UUID', 'member');"

must_haves:
  truths:
    - "A JWT issued after login contains a 'user_role' claim (e.g. 'member')"
    - "RLS policies that check (auth.jwt() ->> 'user_role') evaluate correctly for authenticated requests"
    - "The custom_access_token_hook function exists and has correct permissions (supabase_auth_admin can execute it)"
    - "TypeScript APP_ROLES constant and hasRole() helper exist and are importable"
    - "The /(app)/dashboard page shows the logged-in user's role"
  artifacts:
    - path: "supabase/migrations/20260211000002_custom_access_token_hook.sql"
      provides: "Hook function, permissions, and auth admin policy for user_roles"
      contains: "custom_access_token_hook"
    - path: "src/lib/auth/roles.ts"
      provides: "APP_ROLES constant, AppRole type, hasRole() helper"
      contains: "hasRole"
  key_links:
    - from: "public.custom_access_token_hook"
      to: "public.user_roles"
      via: "SELECT role FROM public.user_roles WHERE user_id = (event->>'user_id')::uuid"
      pattern: "user_roles.*user_id"
    - from: "JWT"
      to: "RLS policy"
      via: "(select (auth.jwt() ->> 'user_role')::public.app_role) in (...)"
      pattern: "auth\\.jwt\\(\\).*user_role"
    - from: "src/routes/(app)/+layout.server.ts"
      to: "src/lib/auth/roles.ts"
      via: "import { hasRole } from '$lib/auth/roles'"
      pattern: "hasRole"
---

<objective>
Implement the Custom Access Token Hook that injects user_role into every JWT, create TypeScript role constants and hierarchy helpers, and verify the complete auth flow end-to-end.

Purpose: Without the hook, RLS policies that check user_role evaluate it as null and deny every query. This is the keystone of the entire permission system. After this plan, roles are embedded in the JWT — no additional DB query per request.
Output: Custom Access Token Hook SQL, TypeScript role helpers, end-to-end verified auth flow with role in JWT.
</objective>

<execution_context>
@/home/iancrowder/.claude/get-shit-done/workflows/execute-plan.md
@/home/iancrowder/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
@.planning/phases/01-foundation/01-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Custom Access Token Hook SQL migration and TypeScript role helpers</name>
  <files>
    supabase/migrations/20260211000002_custom_access_token_hook.sql
    src/lib/auth/roles.ts
  </files>
  <action>
    Create `supabase/migrations/20260211000002_custom_access_token_hook.sql`:

    ```sql
    -- ============================================================
    -- Custom Access Token Hook
    --
    -- Called by Supabase Auth every time a JWT is issued (login + token refresh).
    -- Reads user's role from user_roles table and injects it as 'user_role' claim.
    --
    -- After this hook is registered in the Dashboard, RLS policies can evaluate
    -- (auth.jwt() ->> 'user_role') without an additional DB round-trip per request.
    --
    -- Source: https://supabase.com/docs/guides/database/postgres/custom-claims-and-role-based-access-control-rbac
    -- ============================================================

    create or replace function public.custom_access_token_hook(event jsonb)
    returns jsonb
    language plpgsql
    stable
    security definer
    set search_path = ''
    as $$
      declare
        claims jsonb;
        user_role public.app_role;
      begin
        -- Read the user's role from user_roles table
        -- user_roles is denied to authenticated users — only accessible to supabase_auth_admin
        select role into user_role
        from public.user_roles
        where user_id = (event->>'user_id')::uuid;

        claims := event->'claims';

        if user_role is not null then
          -- Inject role as string into JWT claims
          claims := jsonb_set(claims, '{user_role}', to_jsonb(user_role));
        else
          -- User has no role assigned — set null so RLS policies deny access cleanly
          claims := jsonb_set(claims, '{user_role}', 'null');
        end if;

        event := jsonb_set(event, '{claims}', claims);
        return event;
      end;
    $$;

    -- Grant supabase_auth_admin permission to call this function
    -- Revoke from everyone else to prevent direct invocation
    grant usage on schema public to supabase_auth_admin;
    grant execute on function public.custom_access_token_hook to supabase_auth_admin;
    revoke execute on function public.custom_access_token_hook from authenticated, anon, public;

    -- Grant supabase_auth_admin read access to user_roles for the hook to work
    grant all on table public.user_roles to supabase_auth_admin;
    revoke all on table public.user_roles from authenticated, anon, public;

    -- RLS policy: allow supabase_auth_admin to read user_roles (required for hook)
    -- The existing "Deny authenticated access to user_roles" restrictive policy
    -- does not apply to supabase_auth_admin role.
    create policy "Allow auth admin to read user roles"
      on public.user_roles
      as permissive for select
      to supabase_auth_admin
      using (true);
    ```

    Apply the migration:
    ```bash
    npx supabase db push
    ```

    IMPORTANT: After the migration is applied, the hook function exists in the database but is NOT yet active. It must be registered in the Supabase Dashboard (see user_setup). The checkpoint task below handles this verification.

    Create `src/lib/auth/` directory, then create `src/lib/auth/roles.ts`:

    ```typescript
    /**
     * Role constants and hierarchy helpers for ASQN 1st SFOD.
     *
     * These mirror the public.app_role PostgreSQL enum exactly.
     * Update both if the enum changes.
     *
     * IMPORTANT: hasRole() is for UI-layer checks only.
     * RLS is the actual enforcement layer — do not rely on client-side role checks for security.
     */

    export const APP_ROLES = ['admin', 'command', 'nco', 'member'] as const
    export type AppRole = typeof APP_ROLES[number]

    /** Numeric hierarchy — higher number = more permissions */
    const ROLE_HIERARCHY: Record<AppRole, number> = {
      admin:   4,
      command: 3,
      nco:     2,
      member:  1,
    }

    /**
     * Returns true if userRole meets or exceeds requiredRole.
     *
     * Examples:
     *   hasRole('admin', 'nco')    // true  — admin outranks nco
     *   hasRole('member', 'nco')   // false — member is below nco
     *   hasRole(null, 'member')    // false — no role = no access
     *
     * Use for UI-layer gates only (show/hide elements, redirect in load functions).
     * Never use as a substitute for RLS.
     */
    export function hasRole(userRole: AppRole | string | null | undefined, requiredRole: AppRole): boolean {
      if (!userRole) return false
      if (!APP_ROLES.includes(userRole as AppRole)) return false
      return ROLE_HIERARCHY[userRole as AppRole] >= ROLE_HIERARCHY[requiredRole]
    }

    /**
     * Returns the display label for a role.
     */
    export function roleLabel(role: AppRole | string | null | undefined): string {
      const labels: Record<AppRole, string> = {
        admin: 'Administrator',
        command: 'Command',
        nco: 'Non-Commissioned Officer',
        member: 'Member',
      }
      if (!role || !APP_ROLES.includes(role as AppRole)) return 'No Role'
      return labels[role as AppRole]
    }
    ```

    Update `src/routes/(app)/dashboard/+page.svelte` to display the role using roleLabel:
    ```svelte
    <script lang="ts">
      import { roleLabel } from '$lib/auth/roles'
      import type { PageData } from './$types'

      let { data }: { data: PageData } = $props()
    </script>

    <div class="min-h-screen bg-black text-white p-8">
      <h1 class="text-2xl font-bold mb-4">ASQN 1st SFOD — Dashboard</h1>
      <p class="text-gray-400">Welcome. You are authenticated.</p>
      <p class="text-gray-400 mt-2">Role: {roleLabel(data.userRole)}</p>
    </div>
    ```

    Run `npm run check` to confirm 0 type errors.
  </action>
  <verify>
    Run `npm run check` — 0 errors.
    Run `npm run build` — builds cleanly.
    Confirm migration file exists: `ls supabase/migrations/20260211000002_custom_access_token_hook.sql`
    Confirm `src/lib/auth/roles.ts` exports APP_ROLES, AppRole, hasRole, and roleLabel.
  </verify>
  <done>
    Migration applied to Supabase (or ready to apply). custom_access_token_hook function exists in the database. src/lib/auth/roles.ts exports all role utilities. `npm run check` and `npm run build` pass.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Register hook in Supabase Dashboard and verify end-to-end auth flow</name>
  <files>
    (no files modified — this task verifies the complete Phase 1 auth system end-to-end)
  </files>
  <action>
    Human verification required. The executor must pause and ask the user to complete the following steps. The hook cannot be registered programmatically — it requires a Dashboard UI action.

    Present the user with the how-to-verify steps below and wait for their "approved" signal before continuing.
  </action>
  <what-built>
    Custom Access Token Hook SQL function deployed. TypeScript role helpers in place. Complete Discord OAuth flow wired (plans 01-01 through 01-04).

    The hook exists in the database but is not active until registered in the Dashboard.
  </what-built>
  <how-to-verify>
    Step 1 — Register the hook:
    1. Go to Supabase Dashboard -> Authentication -> Hooks
    2. Find "Custom Access Token Hook"
    3. Click "Add hook" -> select function: `public.custom_access_token_hook`
    4. Save

    Step 2 — Assign yourself a role (so the hook has a role to inject):
    Run this SQL in Supabase Dashboard -> SQL Editor:
    ```sql
    -- Replace with your actual auth.users UUID (find it under Authentication -> Users)
    INSERT INTO public.user_roles (user_id, role)
    VALUES ('YOUR-AUTH-USER-UUID', 'member')
    ON CONFLICT DO NOTHING;
    ```

    Step 3 — Test the full auth flow:
    1. Start the dev server: `npm run dev`
    2. Navigate to http://localhost:5173/auth/login
    3. Click "Sign in with Discord" and complete OAuth
    4. You should arrive at http://localhost:5173/dashboard
    5. The page should show "Role: Member" (from roleLabel())

    Step 4 — Verify JWT contains user_role:
    1. In the browser dev tools, open Application -> Cookies -> localhost
    2. Find the `sb-*-auth-token` cookie
    3. Copy the `access_token` value
    4. Visit https://jwt.io and paste the token
    5. The payload should contain: `"user_role": "member"`

    Step 5 — Verify session persists across refresh:
    1. While on /dashboard, press Ctrl+R (hard refresh)
    2. Should remain on /dashboard (not redirected to /auth/login)

    Step 6 — Verify session guard works:
    1. Clear cookies or open an incognito window
    2. Navigate directly to http://localhost:5173/dashboard
    3. Should redirect to /auth/login

    Expected outcome:
    - Dashboard shows "Role: Member" (or whatever role you assigned)
    - JWT at jwt.io shows user_role claim
    - Refresh keeps session
    - Unauthenticated access redirects to login
  </how-to-verify>
  <verify>
    User confirms all 6 verification steps pass via "approved" signal.
    JWT decoded at jwt.io contains `"user_role": "member"` (or assigned role).
    Dashboard page displays the role label.
  </verify>
  <done>
    User has typed "approved". JWT contains user_role claim. Dashboard shows role. Session persists on refresh. Unauthenticated access redirects to login. Phase 1 is complete.
  </done>
  <resume-signal>Type "approved" if all 6 steps pass, or describe which step failed and what you saw.</resume-signal>
</task>

</tasks>

<verification>
1. `npm run check` — 0 type errors
2. `npm run build` — clean build
3. Dashboard shows logged-in user's role (Member/NCO/Command/Admin)
4. JWT decoded at jwt.io contains `user_role` claim
5. Browser refresh on /dashboard keeps session (no redirect to login)
6. Unauthenticated navigation to /dashboard redirects to /auth/login
7. `supabase/migrations/20260211000002_custom_access_token_hook.sql` exists
8. `src/lib/auth/roles.ts` exports APP_ROLES, AppRole, hasRole, roleLabel
</verification>

<success_criteria>
- Custom Access Token Hook is registered and active (confirmed by JWT containing user_role)
- RLS policies on soldiers/service_records/ranks/units can evaluate user_role from JWT without a DB round-trip
- TypeScript role constants mirror PostgreSQL app_role enum exactly
- hasRole() correctly implements 4-tier hierarchy (admin >= command >= nco >= member)
- Complete Phase 1 success criteria met:
  1. Discord OAuth login works without a password
  2. Sessions persist across browser refresh
  3. Unauthenticated access to /(app) routes redirects to login
  4. JWT contains user_role claim (hook active)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-04-SUMMARY.md`
</output>
