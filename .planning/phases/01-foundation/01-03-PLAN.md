---
phase: 01-foundation
plan: "03"
type: execute
wave: 2
depends_on:
  - "01-01"
files_modified:
  - supabase/migrations/20260211000000_initial_schema.sql
  - supabase/migrations/20260211000001_rls_policies.sql
  - src/lib/types/database.ts
autonomous: true

user_setup:
  - service: supabase
    why: "Supabase project must exist to push migrations and generate types"
    env_vars:
      - name: PUBLIC_SUPABASE_URL
        source: "Supabase Dashboard -> Project Settings -> API -> Project URL"
      - name: PUBLIC_SUPABASE_PUBLISHABLE_KEY
        source: "Supabase Dashboard -> Project Settings -> API -> anon/public key"
    dashboard_config:
      - task: "Link local project to Supabase cloud project"
        location: "Run: npx supabase login && npx supabase link --project-ref YOUR_PROJECT_REF"

must_haves:
  truths:
    - "All 5 tables exist in the Supabase project: soldiers, ranks, units, service_records, user_roles"
    - "RLS is enabled on every table — no table has 0 policies"
    - "service_records has no UPDATE or DELETE policies (append-only enforced at DB level)"
    - "The app_role enum exists with values: admin, command, nco, member"
    - "src/lib/types/database.ts is generated and reflects the current schema"
  artifacts:
    - path: "supabase/migrations/20260211000000_initial_schema.sql"
      provides: "Table definitions for all 5 core tables"
      contains: "enable row level security"
    - path: "supabase/migrations/20260211000001_rls_policies.sql"
      provides: "Baseline RLS policies for all tables"
      contains: "create policy"
    - path: "src/lib/types/database.ts"
      provides: "Generated TypeScript types from Supabase schema"
      contains: "soldiers"
  key_links:
    - from: "public.soldiers"
      to: "auth.users"
      via: "user_id uuid references auth.users on delete set null"
      pattern: "references auth.users"
    - from: "public.service_records"
      to: "public.soldiers"
      via: "soldier_id uuid not null references public.soldiers on delete cascade"
      pattern: "references public.soldiers"
    - from: "public.user_roles"
      to: "auth.users"
      via: "user_id uuid references auth.users on delete cascade"
      pattern: "references auth.users"
    - from: "RLS policies"
      to: "auth.jwt() ->> 'user_role'"
      via: "(select (auth.jwt() ->> 'user_role')::public.app_role) in (...)"
      pattern: "auth\\.jwt\\(\\).*user_role"
---

<objective>
Create the core database schema with RLS enabled on every table from the start, baseline RLS policies, and generate TypeScript types.

Purpose: The schema is locked before any feature queries it. The append-only constraint on service_records is irreversible once data exists — it must be correct here. RLS disabled even briefly after data exists exposes rows to the anon key. TypeScript types from this plan unblock plan 01-02's type import.
Output: 5 tables with RLS, baseline policies, generated database.ts types file.
</objective>

<execution_context>
@/home/iancrowder/.claude/get-shit-done/workflows/execute-plan.md
@/home/iancrowder/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Database schema migration — 5 tables with RLS enabled at creation</name>
  <files>
    supabase/migrations/20260211000000_initial_schema.sql
  </files>
  <action>
    Initialize Supabase in the project (if not already done):
    ```bash
    npx supabase init
    ```

    Create `supabase/migrations/20260211000000_initial_schema.sql`:

    ```sql
    -- ============================================================
    -- Phase 1: Core Schema
    -- Decisions locked:
    --   - service_records is append-only — no UPDATE or DELETE policies will ever be created
    --   - RLS is enabled on every table at creation — no exceptions
    --   - app_role enum is the single source of truth for role hierarchy
    -- ============================================================

    -- 4-tier role hierarchy enum — matches TypeScript APP_ROLES constant
    create type public.app_role as enum ('admin', 'command', 'nco', 'member');

    -- ============================================================
    -- ranks: reference table — rank definitions for display and sort
    -- ============================================================
    create table public.ranks (
      id            uuid primary key default gen_random_uuid(),
      name          text not null unique,          -- e.g. "Staff Sergeant"
      abbreviation  text not null,                 -- e.g. "SSG"
      sort_order    int not null,                  -- lower = lower rank (E-5 < E-7)
      insignia_url  text,                          -- Supabase Storage URL, nullable until images uploaded
      created_at    timestamptz not null default now()
    );
    alter table public.ranks enable row level security;

    -- ============================================================
    -- units: self-referential tree for ORBAT (Squadron > Troop > Team)
    -- ============================================================
    create table public.units (
      id              uuid primary key default gen_random_uuid(),
      name            text not null,
      abbreviation    text,
      parent_unit_id  uuid references public.units(id) on delete set null,
      created_at      timestamptz not null default now()
    );
    alter table public.units enable row level security;

    -- ============================================================
    -- soldiers: primary personnel record
    -- ============================================================
    create table public.soldiers (
      id            uuid primary key default gen_random_uuid(),
      user_id       uuid references auth.users(id) on delete set null unique,
      discord_id    text unique,                   -- Discord snowflake ID — separate from internal UUID
      display_name  text not null,
      callsign      text,
      mos           text,                          -- e.g. '18B', 'Rifleman'
      status        text not null default 'active'
                      check (status in ('active', 'inactive', 'loa', 'awol', 'discharged')),
      rank_id       uuid references public.ranks(id) on delete set null,
      unit_id       uuid references public.units(id) on delete set null,
      joined_at     timestamptz not null default now(),
      created_at    timestamptz not null default now(),
      updated_at    timestamptz not null default now()
    );
    alter table public.soldiers enable row level security;

    -- ============================================================
    -- service_records: append-only event log
    -- INVARIANT: No UPDATE or DELETE policies will ever be created on this table.
    -- Enforcing append-only at the DB layer: RLS simply omits UPDATE/DELETE policies.
    -- When RLS is enabled and no policy exists for an operation, that operation is denied.
    -- ============================================================
    create table public.service_records (
      id            uuid primary key default gen_random_uuid(),
      soldier_id    uuid not null references public.soldiers(id) on delete cascade,
      action_type   text not null
                      check (action_type in (
                        'rank_change', 'award', 'qualification',
                        'transfer', 'status_change', 'enlistment', 'note'
                      )),
      payload       jsonb not null default '{}',   -- flexible per action_type
      performed_by  uuid references auth.users(id) on delete set null,
      visibility    text not null default 'public'
                      check (visibility in ('public', 'leadership_only')),
      occurred_at   timestamptz not null default now()
      -- NOTE: no updated_at — this table is append-only by design
    );
    alter table public.service_records enable row level security;

    -- ============================================================
    -- user_roles: drives the Custom Access Token Hook (plan 01-04)
    -- Permissions on this table are tightly controlled — only supabase_auth_admin
    -- reads it during JWT issuance. Authenticated users cannot read or write their own row.
    -- ============================================================
    create table public.user_roles (
      id        bigint generated by default as identity primary key,
      user_id   uuid references auth.users(id) on delete cascade not null,
      role      public.app_role not null,
      unique (user_id, role),
      created_at timestamptz not null default now()
    );
    alter table public.user_roles enable row level security;

    -- updated_at trigger for soldiers table
    create or replace function public.set_updated_at()
    returns trigger
    language plpgsql
    as $$
    begin
      new.updated_at = now();
      return new;
    end;
    $$;

    create trigger soldiers_updated_at
      before update on public.soldiers
      for each row execute function public.set_updated_at();
    ```

    Apply the migration to the Supabase cloud project:
    ```bash
    npx supabase db push
    ```

    If `supabase link` has not been run yet, the executor should note this in the SUMMARY and leave the migration file ready for manual push. The migration file itself must be created regardless.
  </action>
  <verify>
    Run the following SQL in Supabase Dashboard -> SQL Editor (this runs as postgres superuser, fine for verification):
    ```sql
    select tablename, rowsecurity
    from pg_tables
    where schemaname = 'public'
    order by tablename;
    ```
    All 5 tables (soldiers, ranks, units, service_records, user_roles) should show `rowsecurity = true`.

    Also verify the app_role enum exists:
    ```sql
    select typname, enumlabel
    from pg_type
    join pg_enum on pg_type.oid = pg_enum.enumtypid
    where typname = 'app_role'
    order by enumsortorder;
    ```
    Should return: admin, command, nco, member.
  </verify>
  <done>
    Migration file exists at supabase/migrations/20260211000000_initial_schema.sql. All 5 tables have RLS enabled. app_role enum has 4 values. service_records has no updated_at column (append-only signal).
  </done>
</task>

<task type="auto">
  <name>Task 2: Baseline RLS policies and TypeScript type generation</name>
  <files>
    supabase/migrations/20260211000001_rls_policies.sql
    src/lib/types/database.ts
  </files>
  <action>
    Create `supabase/migrations/20260211000001_rls_policies.sql` with baseline RLS policies:

    ```sql
    -- ============================================================
    -- Baseline RLS Policies
    --
    -- Policy design:
    --   - Wrap auth.jwt() in SELECT to cache result per statement (not per row)
    --   - service_records: SELECT and INSERT only — no UPDATE or DELETE (append-only)
    --   - user_roles: deny all authenticated access — only supabase_auth_admin reads it
    -- ============================================================

    -- ranks: all authenticated users can read; only admin/command can write
    create policy "Authenticated can read ranks"
      on public.ranks for select
      to authenticated
      using (true);

    create policy "Admin can manage ranks"
      on public.ranks for all
      to authenticated
      using (
        (select (auth.jwt() ->> 'user_role')::public.app_role) = 'admin'
      );

    -- units: all authenticated users can read; only admin/command can write
    create policy "Authenticated can read units"
      on public.units for select
      to authenticated
      using (true);

    create policy "Admin and command can manage units"
      on public.units for all
      to authenticated
      using (
        (select (auth.jwt() ->> 'user_role')::public.app_role)
          in ('admin', 'command')
      );

    -- soldiers: authenticated users can read active soldiers; NCO+ can write
    create policy "Authenticated can read active soldiers"
      on public.soldiers for select
      to authenticated
      using (status = 'active');

    create policy "NCO and above can insert soldiers"
      on public.soldiers for insert
      to authenticated
      with check (
        (select (auth.jwt() ->> 'user_role')::public.app_role)
          in ('nco', 'command', 'admin')
      );

    create policy "NCO and above can update soldiers"
      on public.soldiers for update
      to authenticated
      using (
        (select (auth.jwt() ->> 'user_role')::public.app_role)
          in ('nco', 'command', 'admin')
      );

    -- Members can read their own soldier record regardless of status
    create policy "Members can read own soldier record"
      on public.soldiers for select
      to authenticated
      using (user_id = (select auth.uid()));

    -- service_records: INSERT for NCO+, SELECT for authenticated.
    -- NO UPDATE or DELETE policies — omitting them enforces append-only via RLS.
    create policy "Authenticated can read public service records"
      on public.service_records for select
      to authenticated
      using (visibility = 'public');

    create policy "NCO and above can read all service records including leadership_only"
      on public.service_records for select
      to authenticated
      using (
        visibility = 'public'
        or (select (auth.jwt() ->> 'user_role')::public.app_role)
          in ('nco', 'command', 'admin')
      );

    create policy "NCO and above can insert service records"
      on public.service_records for insert
      to authenticated
      with check (
        (select (auth.jwt() ->> 'user_role')::public.app_role)
          in ('nco', 'command', 'admin')
      );

    -- user_roles: deny all authenticated/anon access
    -- Only supabase_auth_admin can read this table (granted in plan 01-04)
    create policy "Deny authenticated access to user_roles"
      on public.user_roles
      as restrictive
      for all
      to authenticated, anon
      using (false);
    ```

    Apply the migration:
    ```bash
    npx supabase db push
    ```

    Then verify RLS coverage — run this SQL in Supabase Dashboard to confirm no table has 0 policies:
    ```sql
    select t.tablename, count(p.policyname) as policy_count
    from pg_tables t
    left join pg_policies p
      on t.tablename = p.tablename and t.schemaname = p.schemaname
    where t.schemaname = 'public'
    group by t.tablename
    order by t.tablename;
    ```
    All tables should show policy_count >= 1.

    Generate TypeScript types from the schema:
    ```bash
    mkdir -p src/lib/types
    npx supabase gen types typescript --linked > src/lib/types/database.ts
    ```

    If `--linked` flag requires prior `supabase link`, use `--project-id YOUR_PROJECT_ID` instead:
    ```bash
    npx supabase gen types typescript --project-id YOUR_SUPABASE_PROJECT_ID > src/lib/types/database.ts
    ```

    After generating, update `src/lib/supabase/server.ts` and `src/lib/supabase/client.ts` to import the Database type properly (remove the `any` workaround from plan 01-02):
    ```typescript
    import type { Database } from '$lib/types/database'
    // Then use: createServerClient<Database>(...)
    ```

    Run `npm run check` to confirm the types wire up correctly.
  </action>
  <verify>
    Run `npm run check` — should pass with 0 errors now that database.ts exists.
    Confirm `src/lib/types/database.ts` exists and contains the `soldiers` table type.
    Run the RLS coverage query above — all 5 tables should have >= 1 policy.
    Confirm `supabase/migrations/20260211000001_rls_policies.sql` contains NO `for update` or `for delete` policy on `service_records`.
  </verify>
  <done>
    RLS policies exist for all 5 tables. service_records has only SELECT and INSERT policies (no UPDATE/DELETE). database.ts is generated and type-checks cleanly against the server and client files from plan 01-02. `npm run check` passes with 0 errors.
  </done>
</task>

</tasks>

<verification>
1. SQL: All 5 tables in pg_tables where schemaname='public' show rowsecurity=true
2. SQL: app_role enum returns admin, command, nco, member
3. SQL: RLS coverage query shows policy_count >= 1 for all tables
4. SQL: service_records policies — only SELECT and INSERT exist (no UPDATE, no DELETE)
5. `src/lib/types/database.ts` exists and contains Database type with soldiers table
6. `npm run check` passes after database.ts is generated
</verification>

<success_criteria>
- 5 tables created with correct schema and RLS enabled at creation
- app_role enum with 4-tier hierarchy (admin, command, nco, member)
- Baseline RLS policies in place for all tables
- service_records enforces append-only via absence of UPDATE/DELETE policies
- TypeScript types generated and wired into Supabase client factories
- Zero type errors after type generation
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
